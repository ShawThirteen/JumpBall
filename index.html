<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Document</title>
<style>
#canvas {
	background: #000;
}
</style>
</head>
<body>
<canvas id="canvas" width="500" height="500"></canvas>
<script>

class Point {
	/*
	* @params gravityX [int] x轴的重力加速度,像素每2次方单位时间
	* @params gravityY [int] y轴的重力加速度,像素每2次方单位时间
	* @params elasticX [int] x轴的弹性系数
	* @params elasticY [int] y轴的弹性系数
	* @params directionX [int] x轴运动方向,正向(向右)为1
	* @params directionY [int] y轴运动方向,正向(向上)为-1
	* @params speedX [int] x轴初始方向速度
	* @params speedY [int] y轴方向初始速度
	* @params startX [int] 物体起始存在的x轴点坐标
	* @params startY [int] 物体起始存在的y轴点坐标
	* @params endX [int] x轴的碰撞点(转向点)
	* @params endY [int] y轴的碰撞点(转向点)
	*/
	constructor (arg) {
		var {
			gravityX = 9.8,
			gravityY = 9.8,
			elasticX = 0.85,
			elasticY = 0.85,
			directionX = 1,
			directionY = 1,
			speedX = 0,
			speedY = 0,
			startX = 0,
			startY = 0,
			endX = 0,
			endY = 0
		} = {...arg};

		this.gravityX = gravityX;
		this.gravityY = gravityY;
		this.elasticX = elasticX;
		this.elasticY = elasticY;
		this.directionX = directionX;
		this.directionY = directionY;
		this.speedX = speedX;
		this.speedY = speedY;
		this.startX = startX;
		this.startY = startY;
		this.endX = endX;
		this.endY = endY;
		this.setPosition(startX, startY);
	}
	/*
	* 设置当前点的位置
	* @params x [int] x坐标
	* @params y [int] y坐标
	*/
	setPosition (x, y) {
		this.x = x;
		this.y = y;
	}
	/*
	* 设置当前运动方向
	*/
	setDirection (x, y) {
		this.directionX *= x;
		this.directionY *= y;
	}
	/*
	* 物体改变运动状态
	* @params frame [int] 帧率,每秒刷新多少次,帧率越大，每个单位时间的刷新位移越小,物体运动越平滑
	* @params callback [function] 每次运动后的回调函数
	*/
	movement (frame, callback) {
		(frame == frame - 0) && (frame = Math.abs(frame)) || (frame = 1);	// 非0，非负数字
		this.delta = 1 / frame || 1 / 13; 	// 每帧耗时,单位秒
		this._changePositionY(callback);
	}

	/*
	* y轴方向上的物体运动
	*/
	_changePositionY (callback) {
		var _this = this;
		var t = this.delta,
			gravity = this.gravityY,
			endY = this.endY,
			speed = this.speedY,
			elastic = this.elasticY

		if (_this.directionY > 0) {	// 正向向下

			var currentDistance = speed * t + 1 / 2 * gravity * t * t;	// 当前这一个单位时间内，下落的距离

			if (_this.y + currentDistance >= endY) {	// 将会发生碰撞
				
				// 下一步要发生碰撞
				var recentHeight = endY - _this.y;	// 本次实际的位移量
				var t1 = (-1 * speed + Math.sqrt(speed * speed + 2 * gravity * recentHeight)) / gravity;
				var t2 = (-1 * speed - Math.sqrt(speed * speed + 2 * gravity * recentHeight)) / gravity;
				var recentDuring = Math.max(t1, t2).toFixed(8);	// 当前实际运动的时间,保留8位有效数字
				_this.y += recentHeight;
				speed += gravity * recentDuring;	// 实际运动的速度

				speed *= elastic;	// 乘以弹性系数,做速度损耗
				_this.setDirection(1, -1);	// 发生碰撞之后, 方向改变了

			} else {	// 可以正常进行
				_this.y += currentDistance;	// 不发生碰撞,继续位移
				speed += gravity * t;			// 位移后,计算新速度
			}

			if (speed < 0.01) {	// 当物体的速度趋近与0,我们认为物体静止了
				_this.y = endY;
				speed = 0;	// 静止
				_this.directionY = 1;	// 恢复默认方向
				console.log('正向静止');
			}
			_this.speedY = speed;	// 保存数据
		} else {	// 负向
			var currentDistance = speed * t - 1 / 2 * gravity * t * t;	// 此次位移的距离
			var singleSpeed = gravity * t;		// 当前单位时间内削减的速度;
			if (speed - singleSpeed <= 0) {		// 物体将要在y轴方向静止
				var recentDuring = (speed / gravity).toFixed(8);	// 此次实际运动的时间
				var recentHeight = 1 / 2 * gravity * recentDuring * recentDuring;
				_this.y -= recentHeight;
				speed = 0;
				_this.directionY = 1;	// 恢复默认方向
			} else {
				_this.y -= currentDistance;  // 此次停留的位置
				speed -= gravity * t;
			}
			_this.speedY = speed;	// 保存数据
		}
		callback && callback({
			x: _this.x,
			y: _this.y,
			directionY: _this.directionY,
			speedY: _this.speedY
		});
	}
}

var ctx = document.getElementById('canvas').getContext('2d');
var elastic = 0.9;
var gravity = 1 / 1;	// 10px/s^2
var startX = 100, startY = 10, r = 5, speed = 0, t = 1, endY = 500, direction = 1;
function draw (x, y) {
	ctx.beginPath();
	ctx.fillStyle = 'red';
	ctx.arc(x, y, r, 0, Math.PI * 2, true);
	ctx.closePath();
	ctx.fill();
}

var ball = new Point({endY: 300});
ball.setPosition(startX, startY);
var timer = setInterval(function () {
	ctx.clearRect(0, 0, 500, 500);
	ball.movement(10, function (data) {
		draw(data.x, data.y)
	})
}, 10)



draw(startX, startY);
var time = 0;

/*var timer = setInterval(function () {
	ctx.clearRect(0, 0, 500, 500);
	nextDraw();
}, 30)*/
function nextDraw () {
	if (direction > 0) {	// 正向
		var currentDistance = speed * t + 1 / 2 * gravity * t * t;	// 当前这一个单位时间内，下落的距离

		if (startY + currentDistance >= endY) {	// 到底了
			
			console.log('当前位置', startY - 10);
			console.log('距离底部', endY - startY);
			console.log('current speed', speed);
			console.log('正常应该下落多少', currentDistance);


			// 下一步要碰到地面了,
			var recentHeight = endY - startY;	// 本次实际的位移量
			var t1 = (-1 * speed + Math.sqrt(speed * speed + 2 * gravity * recentHeight)) / gravity;
			var t2 = (-1 * speed - Math.sqrt(speed * speed + 2 * gravity * recentHeight)) / gravity;
			var recentDuring = Math.max(t1, t2).toFixed(8);	// 保留8位有效数字
			startY += recentHeight;
			speed += gravity * recentDuring;	// 实际坠地的速度

			speed *= elastic;	// 乘以弹性系数,做速度损耗
			console.log('当然下落高度', startY - 10, '; 当前速度:', speed);
			console.log('当前单位时间下落了', recentHeight, '到底了');

			// 到底部之后,球反弹了, 方向改变了
			direction = -1;

			if (speed < 0.01) {	// 当物体下落的速度趋近与0,我们认为物体静止了
				startY = endY;
				speed = 0;
				direction = 1;
				clearInterval(timer);
			}

		} else {	// 可以正常进行
			startY += currentDistance;	// 1. 先是下落位移
			speed += gravity * t;			// 下落后，在计算新速度
			
			console.log('当然下落高度', startY - 10, '; 当前速度:', speed);
			console.log('当前单位时间下落了', currentDistance)
		}
	} else {	// 负向
		var currentDistance = speed * t - 1 / 2 * gravity * t * t;	// 此次位移的距离
		var singleSpeed = gravity * t;		// 当前单位时间内削减的速度;
		if (speed - singleSpeed <= 0) {		// 触发顶部

			var recentDuring = (speed / gravity).toFixed(8);	// 此次实际运动的时间
			var recentHeight = 1 / 2 * gravity * recentDuring * recentDuring;
			startY -= recentHeight;
			speed = 0;
			direction = 1;
			console.log('下一步就会速度小于0');
			console.log('当前速度是', speed);
			console.log('当前位置是', startY);
		} else {
			startY -= currentDistance;  // 此次停留的位置
			speed -= gravity * t;
		}
	}
	draw(startX, startY);
	time++;
}

</script>
</body>
</html>